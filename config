#—É–±—Ä–∞—Ç—å –Ω—Ñ –Ω–µ–π–º—Å
#–ø–æ–∫–∞ –Ω–µ 57 –∏–∑ 57 –ø–æ–¥–∞—Ä–∫–æ–≤ –±–æ—Ç –Ω–µ –¥–∞–µ—Ç –æ—Ç–≤–µ—Ç–∞

import os
import json
import time
import requests
import telebot
import asyncio
import httpx
from datetime import datetime, timedelta
from dotenv import load_dotenv
from concurrent.futures import ThreadPoolExecutor
import threading
from flask import Flask, render_template, jsonify
import subprocess
import atexit

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()
BOT_TOKEN = os.getenv('BOT_TOKEN')

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Flask
app = Flask(__name__)

# URL –æ—Ç –∑–∞–ø—É—â–µ–Ω–Ω–æ–≥–æ ngrok (–Ω—É–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ ngrok)
# 1. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ç–µ—Ä–º–∏–Ω–∞–ª–µ: ngrok http 5000
# 2. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ URL –∏–∑ –≤—ã–≤–æ–¥–∞ ngrok
# 3. –í—Å—Ç–∞–≤—å—Ç–µ –µ–≥–æ —Å—é–¥–∞
WEBAPP_URL = "https://your-ngrok-url.ngrok-free.app"  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ URL –∏–∑ ngrok

# –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
def cleanup():
    pass

atexit.register(cleanup)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = telebot.TeleBot(BOT_TOKEN)

# –ö—ç—à –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ü–µ–Ω
price_cache = {}
CACHE_DURATION = timedelta(minutes=10)  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤—Ä–µ–º—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è –¥–æ 10 –º–∏–Ω—É—Ç
RATE_LIMIT_WINDOW = 60  # –æ–∫–Ω–æ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
MAX_REQUESTS_PER_WINDOW = 30  # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –æ–∫–Ω–µ
request_timestamps = []

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è GetGems API
GETGEMS_RATE_LIMIT_WINDOW = 60  # –æ–∫–Ω–æ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
GETGEMS_MAX_REQUESTS = 50  # –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É
getgems_request_timestamps = []

# –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É —Å —Ü–µ–Ω–∞–º–∏
PRICES_FILE = "nft_prices.json"

def check_rate_limit():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤"""
    current_time = time.time()
    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –º–µ—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–∏
    while request_timestamps and current_time - request_timestamps[0] > RATE_LIMIT_WINDOW:
        request_timestamps.pop(0)
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏ –ª–∏–º–∏—Ç
    return len(request_timestamps) < MAX_REQUESTS_PER_WINDOW

def add_request_timestamp():
    """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–ø—Ä–æ—Å–∞"""
    request_timestamps.append(time.time())

def check_getgems_rate_limit():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ GetGems API"""
    current_time = time.time()
    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –º–µ—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–∏
    while getgems_request_timestamps and current_time - getgems_request_timestamps[0] > GETGEMS_RATE_LIMIT_WINDOW:
        getgems_request_timestamps.pop(0)
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏ –ª–∏–º–∏—Ç
    return len(getgems_request_timestamps) < GETGEMS_MAX_REQUESTS

def add_getgems_request_timestamp():
    """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–ø—Ä–æ—Å–∞ –∫ GetGems API"""
    getgems_request_timestamps.append(time.time())

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
COLLECTIONS = {
    "PlushPepes": "EQBG-g6ahkAUGWpefWbx-D_9sQ8oWbvy6puuq78U2c4NUDFS",
    "ToyBears": "EQC1gud6QO8NdJjVrqr7qFBMO0oQsktkvzhmIRoMKo8vxiyL",
    "SwissWatches": "EQBI07PXew94YQz7GwN72nPNGF6htSTOJkuU4Kx_bjTZv32U",
    "PreciousPeaches": "EQA4i58iuS9DUYRtUZ97sZo5mnkbiYUBpWXQOe3dEUCcP1W8",
    "LootBags": "EQCE80Aln8YfldnQLwWMvOfloLGgmPY0eGDJz9ufG3gRui3D",
    "DurovsCaps": "EQD9ikZq6xPgKjzmdBG0G0S80RvUJjbwgHrPZXDKc_wsE84w",
    "LolPops": "EQC6zjid8vJNEWqcXk10XjsdDLRKbcPZzbHusuEW6FokOWIm",
    "PartySparklers": "EQCa1I09fE9UoTV6awM6QC9-fkv51hoii24w1tJoFfigG_ax",
    "ScaredCats": "EQATuUGdvrjLvTWE5ppVFOVCqU2dlCLUnKTsu0n1JYm9la10",
    "SignetRings": "EQCrGA9slCoksgD-NyRDjtHySKN0Ts8k6hdueJkUkZZdD4_K",
    "DiamondRings": "EQCWh1lPltyTwCWxCXm4umL5tPZoXR8kTIcT-pd0JqoadLHo",
    "VoodooDolls": "EQCNsmpHqRSY_Dxnyh6P0MMO7zcABf8sVvG0wr245pBzO3B3",
    "EasterEggs": "EQAwnP7dGfE_WO0xiCiulkAXUG1K1bWH1vE1k64T4G-7gruO",
    "SpicedWines": "EQA8DCWyCWyywgOKYORerRoSVevWrUQ_FjKQgNihxY1227x7",
    "GoldBars": "EQA401QqpXtBnwIaDbFjwd5yXfP2mYiCusbJ3Zcw9eXR9CqL",
    "Champagne": "EQCyAMkb6bNyNlKPH0tJbubk1VVjASqyq9sZwkJ8AbxMkxxU",
    "Skateboard": "EQDTro-ogJbS7o-OBD6bt2NysPt7SnGm5zfuRXGB1nE_rbGa",
    "GamingConsole": "EQD6mH9bwbn6S3M_tCRWOvqAIW8M34kRwbI01niGLRPeDPsl",
    "Sneakers": "EQD7yDu2WCgd9Uzx1dF_DQkWK7IZJJ4Mp9M9g1rGUUiQE43m",
    "Perfume": "EQDQ6DjRabTYSAxf2xrZsnsXtqcIm1bj9dF5x_h8lNjWPmH4",
    "Sunglasses": "EQADvJxMxCHA7fRlYjoceBORf7RwKs0rzjVaKepQACMnZzG7",
    "Guitar": "EQDJsN9OJBhKGZoWZWtkEpzkCfIu16Z9UzTWbYjeLpuHdT5f",
    "Camera": "EQBCe75G0AhjqC64B7H_BHP0wgfONX_x98rszmsEwndDVAjG",
    "Surfboard": "EQDr4xn5_GoCzDxhGJMek7fv3nm6W7bhRvlDSBjcNZul52tZ",
    "Telescope": "EQAwzubeoJwnqmmBuTPpnUSurRzWPB8ERzcfzx55Z2YjE0jx",
    "Yacht": "EQBayCY2wZwrVBExNfLL8v9K0mHNmrQTntZldgpYiRwB_QKK",
    "Motorcycle": "EQDL7HMbca0FufrjHFcRoiLkEiOXkXoO_vH2gVUN8JNp4khK",
    "Helicopter": "EQBaOL8mH5YywkXjkps65X1OLPNH7pns4YcfLmaVpFaoNKZn",
    "Jetpack": "EQBw2tO5UaJ4c_YXt3I8y5KD0k37staZxedV2O5HmryiK0dN",
    "Hoverboard": "EQAOYYJib8K6-91TjeOYRbWEtbtRJHXKoWltnULwdaqd7mR5",
    "RacingCar": "EQCZxxFMS-y1hcGADL6EPB7usNstQqD9u-yBaYpXVVMr75NF",
    "Spaceship": "EQAtFU9GrGfix4UG9DOivN58QxvgBJUaAZ_pdZBZCmbhKo4P",
    "TimeMachine": "EQCDBbQYbv3n91TwywBRD9YrJNuNVmbD3Sprpq6hWIDHVu4p",
    "Submarine": "EQBdlKhLzezYFMCWSWTCnhpKC1uyczaBUOj3EtPjcatUsTrC",
    "JetSki": "EQBG2o0lp-6Oy86NGEJm717BeTDAw_F5ELkgaX2l9UsfavWE",
    "Snowmobile": "EQBMcfMAZlMUr1W3X8kdEw3fJMUAaWH4-XcmE5R5RfFIY0E2",
    "Parachute": "EQCwEFfUbbR-22fn3VgxUpBil7bwBQqEHm7wgQYbWY9c08YJ",
    "HotAirBalloon": "EQDumy3bnZYzV4bSWMSSZkmXqx50XuH5d9RlX_yEi2FNlivk",
    "Sailboat": "EQCt2C3yCRNX267B3l6h1QsU6agm4ZgTAb7NpVGiFKlBXOAA",
    "Bicycle": "EQB4x3sT1DVdODzay3H-4VJIdOooS5-kTgyKcYMZWogPOsiq",
    "ElectricScooter": "EQAPNu648fe_uqUoeH6V_-fIDJYea_5Xu2rXn6iZFil49bMY",
    "Skateboard2": "EQBD8aBKC4NsnYMqtkCfPQk2EVnieynJQp1UgZVyx1VmR5Ml",
    "Rollerblades": "EQC8WVW9DSN4PPfFlCW2AHJkXxBUHBFsvnhXiYqSTpD7tXsp",
    "Surfboard2": "EQB8zLzEOFQK3qTyMYgPD8BuzmNwblnouqaB80PW-s2E7nct",
    "WakeBoard": "EQA_kx2WOydXWzYUYO1DP80aHl4yhlLGYhxjPAtRPNjMgfYM",
    "Snowboard": "EQAtgbhSHOqTxjuRLLOAab6T66FPcQWTNd_DT3VgCG1-tHJw",
    "MountainBike": "EQCBK_JBASAA5XVz1D17Pn--kQaMWm0b9wReVtsEdRO4Tgy9",
    "DirtBike": "EQB6AtBPOuTtQml8oSA7X8ZqJ5QmcOYYqoz92sQYXGUQrxyB",
    "QuadBike": "EQBT9PbZBR6FGcZBSnwgo-DLpc0r7_X_8dlhG5UA6v9l9uJM",
    "Segway": "EQDLM65t0shS7gZAg0lMltGHYhsU94PzsMJHhYibmRV7kdUs",
    "HoverBoard2": "EQC2lsUy1SKxJEJBwj5ZCfVnLPvAqDqy5c26Xg8xS_pDTXGk",
    "ElectricUnicycle": "EQCehrkZtKDtVe0qyvBAsrHx3hW-hroQyDrS_MZOOVYth2DG",
    "FlyingCarpet": "EQAaTIR7oJyowDiumYLVN0oe61kGE3I6EPEn7WgHPGuWAeCy",
    "Teleporter": "EQDqHwSzU4I_U44vSM9EDP4HGGKWy9yWjbzkpCa3K8iMBEVD",
    "RocketBoots": "EQAIM-5QzZGXYTSZR1RGeT2g9rNpYmNPQ09_HtvaInHaTyPX",
    "GravityBoots": "EQBzZLNIr4lie0pTfrbRsANJOtFYwY5gmngRfs84Ras5-aVN"
}

def get_collection_floor_price(collection_address, collection_name):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Ü–µ–Ω—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    if collection_name in price_cache:
        cache_data = price_cache[collection_name]
        if datetime.now() - cache_data['timestamp'] < CACHE_DURATION:
            return cache_data

    max_retries = 3
    base_delay = 2
    
    for attempt in range(max_retries):
        try:
            # –ü–æ–ª—É—á–∞–µ–º –±–∞–∑–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
            collection_response = requests.get(
                f"https://tonapi.io/v2/nfts/collections/{collection_address}",
                headers={
                    'Accept': 'application/json',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                },
                timeout=10
            )
            
            if collection_response.status_code != 200:
                if attempt < max_retries - 1:
                    time.sleep(base_delay * (attempt + 1))
                    continue
                return None
            
            # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥–º–µ—Ç—ã –Ω–∞ –ø—Ä–æ–¥–∞–∂–µ
            response = requests.get(
                f"https://tonapi.io/v2/nfts/collections/{collection_address}/items",
                params={
                    "limit": 1000,
                    "offset": 0,
                    "sale": True,
                    "indirect_sale": True
                },
                headers={
                    'Accept': 'application/json',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                },
                timeout=10
            )
            
            if response.status_code == 429:
                retry_after = int(response.headers.get('Retry-After', base_delay * (attempt + 1)))
                time.sleep(retry_after)
                continue
            
            if response.status_code != 200:
                if attempt < max_retries - 1:
                    time.sleep(base_delay * (attempt + 1))
                    continue
                return None
            
            data = response.json()
            items = data.get('nft_items', [])
            
            valid_prices = []
            for item in items:
                sale = item.get('sale', {})
                if not sale:
                    continue
                
                price = None
                if isinstance(sale, dict):
                    price_fields = ['price', 'full_price', 'value']
                    for field in price_fields:
                        if field in sale:
                            if isinstance(sale[field], dict):
                                price = sale[field].get('value')
                            else:
                                price = sale[field]
                            if price:
                                break
                
                if not price:
                    continue
                
                try:
                    price_value = int(price)
                    if price_value > 0:
                        nft_address = item.get('address')
                        if nft_address:
                            nft_response = requests.get(
                                f"https://tonapi.io/v2/nfts/{nft_address}",
                                headers={
                                    'Accept': 'application/json',
                                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                                },
                                timeout=10
                            )
                            
                            if nft_response.status_code == 200:
                                nft_data = nft_response.json()
                                preview_url = None
                                
                                if 'metadata' in nft_data and 'image' in nft_data['metadata']:
                                    preview_url = nft_data['metadata']['image']
                                
                                if not preview_url and 'previews' in nft_data and nft_data['previews']:
                                    preview_url = nft_data['previews'][0].get('url')
                                
                                if preview_url:
                                    if preview_url.startswith('ipfs://'):
                                        preview_url = f"https://ipfs.io/ipfs/{preview_url[7:]}"
                                    elif not preview_url.startswith(('http://', 'https://')):
                                        preview_url = f"https://{preview_url}"
                                    
                                    valid_prices.append((price_value, item, preview_url))
                                    continue
                            
                except Exception:
                    continue
            
            if valid_prices:
                valid_prices.sort(key=lambda x: x[0])
                min_price, min_price_item, preview_url = valid_prices[0]
                result = {
                    'price': str(min_price),
                    'name': min_price_item.get('metadata', {}).get('name', collection_name),
                    'address': min_price_item.get('address', ''),
                    'image_url': preview_url,
                    'timestamp': datetime.now()
                }
                price_cache[collection_name] = result
                return result
            
            return None
                
        except Exception:
            if attempt < max_retries - 1:
                time.sleep(base_delay * (attempt + 1))
            else:
                return None
    
    return None

def get_all_floor_prices():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö —Ü–µ–Ω"""
    current_prices = {}
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    current_time = datetime.now()
    for collection_id, price_data in price_cache.items():
        if current_time - price_data['timestamp'] < CACHE_DURATION:
            current_prices[collection_id] = price_data
    
    # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—ã —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –≤ –∫—ç—à–µ
    collections_to_check = [(cid, addr) for cid, addr in COLLECTIONS.items() if cid not in current_prices]
    
    if not collections_to_check:
        return current_prices
    
    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é –∫–æ–ª–ª–µ–∫—Ü–∏—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ
    for collection_id, collection_address in collections_to_check:
        try:
            result = get_collection_floor_price(collection_address, collection_id)
            if result:
                current_prices[collection_id] = result
            
            # –î–µ–ª–∞–µ–º –Ω–µ–±–æ–ª—å—à—É—é –ø–∞—É–∑—É –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
            time.sleep(1)  # 1 —Å–µ–∫—É–Ω–¥–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
            
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–µ–Ω—ã –¥–ª—è {collection_id}: {str(e)}")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—É—á–µ–Ω—ã –≤—Å–µ —Ü–µ–Ω—ã
    if len(current_prices) != len(COLLECTIONS):
        missing_collections = set(COLLECTIONS.keys()) - set(current_prices.keys())
        print(f"–ü–æ–ª—É—á–µ–Ω–æ —Ç–æ–ª—å–∫–æ {len(current_prices)} –∏–∑ {len(COLLECTIONS)} —Ü–µ–Ω")
        print(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —Ü–µ–Ω—ã –¥–ª—è: {', '.join(missing_collections)}")
        return None
        
    return current_prices

def format_ton(nano_tons):
    """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –Ω–∞–Ω–æ–¢–û–ù –≤ –¢–û–ù —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
    if nano_tons is None:
        return "–ù–µ—Ç —Ü–µ–Ω—ã"
    try:
        tons = float(nano_tons) / 1000000000
        return f"{tons:.2f} TON"
    except (ValueError, TypeError):
        return "–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —Ü–µ–Ω—ã"

def save_prices_to_file(prices):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ü–µ–Ω –≤ —Ñ–∞–π–ª"""
    try:
        with open(PRICES_FILE, 'w', encoding='utf-8') as f:
            json.dump(prices, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ü–µ–Ω –≤ —Ñ–∞–π–ª: {str(e)}")

def load_prices_from_file():
    """–ó–∞–≥—Ä—É–∑–∫–∞ —Ü–µ–Ω –∏–∑ —Ñ–∞–π–ª–∞"""
    try:
        if os.path.exists(PRICES_FILE):
            with open(PRICES_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫–æ–≤—ã–µ timestamp –æ–±—Ä–∞—Ç–Ω–æ –≤ –æ–±—ä–µ–∫—Ç—ã datetime
                for collection_id, price_data in data.items():
                    price_data['timestamp'] = datetime.fromisoformat(price_data['timestamp'])
                return data
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ü–µ–Ω –∏–∑ —Ñ–∞–π–ª–∞: {str(e)}")
    return {}

def update_prices_loop():
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω"""
    while True:
        try:
            print("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω...")
            prices = get_all_floor_prices()
            if prices:
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º datetime –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ JSON
                prices_to_save = {}
                for collection_id, price_data in prices.items():
                    prices_to_save[collection_id] = price_data.copy()
                    prices_to_save[collection_id]['timestamp'] = price_data['timestamp'].isoformat()
                
                save_prices_to_file(prices_to_save)
                print(f"–¶–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {datetime.now().strftime('%H:%M:%S')}")
            else:
                print("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—ã")
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω: {str(e)}")
        
        time.sleep(60)  # –ü–∞—É–∑–∞ 1 –º–∏–Ω—É—Ç–∞

@bot.message_handler(commands=['start'])
def send_welcome(message):
    keyboard = telebot.types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    keyboard.add(
        telebot.types.KeyboardButton('üéÅ –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Ü–µ–Ω—ã'),
        telebot.types.KeyboardButton('üìä –¢–æ–ø 10 –¥–µ—à–µ–≤—ã—Ö'),
        telebot.types.KeyboardButton('üîî –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è'),
        telebot.types.KeyboardButton('üîï –û—Ç–ø–∏—Å–∞—Ç—å—Å—è')
    )
    
    bot.reply_to(
        message,
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ü–µ–Ω –Ω–∞ NFT —Ç–µ–ª–µ–≥—Ä–∞–º-–ø–æ–¥–∞—Ä–∫–∏.\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=keyboard
    )

@bot.message_handler(func=lambda message: message.text == 'üéÅ –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Ü–µ–Ω—ã')
def show_all_prices(message):
    try:
        processing_msg = bot.reply_to(message, "üîÑ –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–∞—Ö...")
        
        prices = load_prices_from_file()
        if not prices:
            bot.edit_message_text(
                "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–∞—Ö. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                chat_id=message.chat.id,
                message_id=processing_msg.message_id
            )
            return
        
        oldest_timestamp = min(price_data['timestamp'] for price_data in prices.values())
        if datetime.now() - oldest_timestamp > timedelta(minutes=5):
            bot.edit_message_text(
                "‚ö†Ô∏è –î–∞–Ω–Ω—ã–µ –æ —Ü–µ–Ω–∞—Ö —É—Å—Ç–∞—Ä–µ–ª–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                chat_id=message.chat.id,
                message_id=processing_msg.message_id
            )
            return
        
        response = "üìä –í—Å–µ —Ü–µ–Ω—ã –Ω–∞ –ø–æ–¥–∞—Ä–∫–∏:\n\n"
        sorted_prices = sorted(prices.items(), key=lambda x: float(x[1]['price']))
        
        for collection_id, price_data in sorted_prices:
            price_ton = format_ton(int(price_data['price']))
            response += f"üéÅ {price_data['name']}: {price_ton}\n"
        
        response += f"\nüïí –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {oldest_timestamp.strftime('%H:%M:%S')}"
        
        bot.edit_message_text(
            response,
            chat_id=message.chat.id,
            message_id=processing_msg.message_id
        )
        
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–µ–Ω: {str(e)}")
        bot.reply_to(message, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

@bot.message_handler(func=lambda message: message.text == 'üìä –¢–æ–ø 10 –¥–µ—à–µ–≤—ã—Ö')
def show_top_10(message):
    try:
        processing_msg = bot.reply_to(message, "üîÑ –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–∞—Ö...")
        
        prices = load_prices_from_file()
        if not prices:
            bot.edit_message_text(
                "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–∞—Ö. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                chat_id=message.chat.id,
                message_id=processing_msg.message_id
            )
            return
        
        sorted_prices = sorted(prices.items(), key=lambda x: float(x[1]['price']))[:10]
        
        response = "üèÜ –¢–æ–ø 10 —Å–∞–º—ã—Ö –¥–µ—à–µ–≤—ã—Ö –ø–æ–¥–∞—Ä–∫–æ–≤:\n\n"
        for i, (collection_id, price_data) in enumerate(sorted_prices, 1):
            price_ton = format_ton(int(price_data['price']))
            response += f"{i}. {price_data['name']}: {price_ton}\n"
        
        bot.edit_message_text(
            response,
            chat_id=message.chat.id,
            message_id=processing_msg.message_id
        )
        
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–æ–ø 10: {str(e)}")
        bot.reply_to(message, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

@bot.message_handler(func=lambda message: message.text == 'üîî –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è')
def subscribe(message):
    user_id = message.from_user.id
    if user_id not in subscriptions:
        subscriptions[user_id] = True
        bot.reply_to(message, "‚úÖ –í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ü–µ–Ω—ã")
    else:
        bot.reply_to(message, "‚ÑπÔ∏è –í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")

@bot.message_handler(func=lambda message: message.text == 'üîï –û—Ç–ø–∏—Å–∞—Ç—å—Å—è')
def unsubscribe(message):
    user_id = message.from_user.id
    if user_id in subscriptions:
        del subscriptions[user_id]
        bot.reply_to(message, "‚úÖ –í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")
    else:
        bot.reply_to(message, "‚ÑπÔ∏è –í—ã –Ω–µ –±—ã–ª–∏ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")

def check_price_changes():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ü–µ–Ω—ã –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"""
    last_prices = {}
    while True:
        try:
            current_prices = get_all_floor_prices()
            
            if current_prices:
                for collection_id, info in current_prices.items():
                    if collection_id not in last_prices:
                        last_prices[collection_id] = info
                        continue
                        
                    if not info or 'price' not in info:
                        continue
                        
                    current_price = info['price']
                    last_price = last_prices[collection_id].get('price')
                    
                    if current_price != last_price:
                        price_diff = float(current_price) / 1000000000 - float(last_price) / 1000000000
                        change_symbol = "üìà" if price_diff > 0 else "üìâ"
                        
                        message = (
                            f"{change_symbol} –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è {info['name']}!\n"
                            f"–ù–æ–≤–∞—è —Ü–µ–Ω–∞: {format_ton(current_price)}\n"
                            f"–°—Ç–∞—Ä–∞—è —Ü–µ–Ω–∞: {format_ton(last_price)}\n"
                            f"–ò–∑–º–µ–Ω–µ–Ω–∏–µ: {price_diff:+.2f} TON\n"
                            f"üîó https://getgems.io/nft/{info['address']}"
                        )
                        
                        for user_id in subscriptions:
                            try:
                                bot.send_message(user_id, message)
                            except Exception as e:
                                print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
                
                last_prices = current_prices.copy()
                
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –≤ check_price_changes: {str(e)}")
        
        time.sleep(300)  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç

@app.route('/')
def index():
    """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞"""
    return render_template('index.html')

@app.route('/api/prices')
def get_prices():
    """API —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω"""
    prices = load_prices_from_file()
    if not prices:
        return jsonify({'error': '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ü–µ–Ω—ã'}), 500
    
    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ü–µ–Ω—ã –≤ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    formatted_prices = []
    for collection_id, price_data in prices.items():
        formatted_prices.append({
            'id': collection_id,
            'name': price_data['name'],
            'price': format_ton(int(price_data['price'])),
            'raw_price': int(price_data['price']),
            'address': price_data['address'],
            'image_url': price_data.get('image_url', ''),  # –î–æ–±–∞–≤–ª—è–µ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            'timestamp': price_data['timestamp'].strftime('%H:%M:%S')
        })
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ü–µ–Ω–µ
    formatted_prices.sort(key=lambda x: x['raw_price'])
    
    return jsonify({
        'prices': formatted_prices,
        'last_update': min(p['timestamp'] for p in formatted_prices)
    })

if __name__ == '__main__':
    # –°–±—Ä–æ—Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
    try:
        bot.get_updates(offset=-1)
    except Exception:
        pass
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ —Ü–µ–Ω—ã –≤ –∫—ç—à –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
    price_cache.update(load_prices_from_file())
    
    # –ó–∞–ø—É—Å–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    price_updater = threading.Thread(target=update_prices_loop)
    price_updater.daemon = True
    price_updater.start()
    
    # –ó–∞–ø—É—Å–∫ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ü–µ–Ω –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    price_checker = threading.Thread(target=check_price_changes)
    price_checker.daemon = True
    price_checker.start()
    
    # –ó–∞–ø—É—Å–∫ Flask –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    flask_thread = threading.Thread(target=lambda: app.run(debug=False, use_reloader=False))
    flask_thread.daemon = True
    flask_thread.start()
    
    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    bot.infinity_polling()
